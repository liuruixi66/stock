# 开发者指南

## 🚀 快速上手

### 新开发者入门流程

1. **环境准备** (预计时间: 30分钟)
2. **代码理解** (预计时间: 2小时)  
3. **本地调试** (预计时间: 1小时)
4. **功能开发** (根据需求)

---

## 🛠️ 开发环境搭建

### 1. 系统要求

```bash
操作系统: Linux/macOS/Windows
Python: 3.8+
数据库: MySQL 8.0+ (可选)
IDE: VS Code / PyCharm
Git: 2.0+
```

### 2. 环境安装

**Step 1: 克隆项目**
```bash
git clone <repository-url>
cd stock-main
```

**Step 2: 创建虚拟环境**
```bash
# 使用 venv
python -m venv venv
source venv/bin/activate  # Linux/macOS
# 或
venv\Scripts\activate     # Windows

# 使用 conda
conda create -n stock_env python=3.9
conda activate stock_env
```

**Step 3: 安装依赖**
```bash
cd backend
pip install -r requirements.txt

# 如果没有 requirements.txt，手动安装核心依赖
pip install django==5.2.4
pip install pandas numpy
pip install django-cors-headers
pip install mysqlclient  # MySQL 支持 (可选)
pip install tushare      # 数据源 (可选)
```

**Step 4: 数据库配置 (可选)**
```bash
# 如果使用 MySQL
mysql -u root -p
CREATE DATABASE stockdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 在 Django 中
python manage.py migrate
```

**Step 5: 启动开发服务器**
```bash
python manage.py runserver 8002
# 或
python start_server.py
```

**Step 6: 验证安装**
```bash
# 测试 API
curl http://127.0.0.1:8002/api/backtest/config/

# 测试信号库
python signal_library.py
```

---

## 📁 项目结构详解

### 目录组织原则

```
stock-main/
├── backend/                 # 后端代码 (主要开发区域)
│   ├── myproject/          # Django 项目配置
│   ├── indicators/         # 技术指标库 (可扩展)
│   ├── 西蒙斯量化回测系统3/  # 第三方回测引擎
│   ├── signal_library.py   # 核心信号库 (主要修改)
│   ├── backtest_integration.py  # API 接口 (常修改)
│   ├── filter_stocks.py    # 股票筛选 (可扩展)
│   ├── tushare_huoqu.py   # 数据获取 (可扩展)
│   └── *.csv              # 测试数据
├── frontend/               # 前端代码
│   ├── src/               # 源代码
│   └── *.html            # 页面文件
└── docs/                  # 文档 (新增)
```

### 核心文件说明

**🔧 必须了解的文件**

1. **signal_library.py** - 核心交易逻辑
   - `SignalLibrary` 类: 主要业务逻辑
   - 信号生成算法: `generate_buy_signal()`, `generate_sell_signal()`
   - 交易执行: `execute_buy_trade()`, `execute_sell_trade()`

2. **backtest_integration.py** - API 接口层
   - `run_backtest_api()`: 主要 API 端点
   - `get_backtest_config_api()`: 配置接口
   - JSON 响应格式定义

3. **myproject/settings.py** - Django 配置
   - 数据库配置
   - CORS 设置
   - 中间件配置

**📊 可扩展的文件**

1. **indicators/** - 技术指标库
   - 每个指标一个文件
   - 标准化的接口规范
   - 便于添加新指标

2. **filter_stocks.py** - 股票筛选
   - 基于各种条件筛选股票
   - 支持自定义筛选规则

3. **tushare_huoqu.py** - 数据源接口
   - 支持多种数据源
   - 标准化数据格式

---

## 🧩 代码架构理解

### 1. 核心类设计

**SignalLibrary 类 (signal_library.py)**

```python
class SignalLibrary:
    """
    交易信号库 - 系统核心类
    
    主要职责:
    1. 信号生成 - 基于技术指标生成买卖信号
    2. 交易执行 - 模拟真实交易过程
    3. 账户管理 - 资金和持仓管理
    4. 历史记录 - 交易记录和统计
    """
    
    def __init__(self, initial_balance=100000):
        self.initial_balance = initial_balance
        self.current_balance = initial_balance
        self.positions = {}  # 持仓: {股票代码: {shares, avg_price}}
        self.signal_history = []  # 信号历史
        
    # 核心方法
    def generate_buy_signal(self, stock_code, df, signal_type='basic'):
        """生成买入信号"""
        
    def generate_sell_signal(self, stock_code, df, signal_type='basic'):
        """生成卖出信号"""
        
    def execute_buy_trade(self, stock_code, price, shares, trade_date):
        """执行买入交易"""
        
    def execute_sell_trade(self, stock_code, price, shares, trade_date):
        """执行卖出交易"""
```

### 2. 信号生成流程

```python
def signal_generation_workflow():
    """
    信号生成工作流程
    
    1. 数据准备
       └─ 加载股票 OHLCV 数据
    
    2. 技术指标计算
       ├─ 调用 indicators 模块
       ├─ 计算 MA, MACD, KDJ 等
       └─ 返回指标数据
    
    3. 信号判断
       ├─ 基于指标数值判断
       ├─ 应用交易规则
       └─ 生成信号序列
    
    4. 信号记录
       ├─ 记录信号详情
       ├─ 执行模拟交易
       └─ 更新账户状态
    """
    pass
```

### 3. API 请求处理流程

```python
def api_request_workflow():
    """
    API 请求处理工作流程
    
    前端请求 → Django URL 路由 → 视图函数 → 业务逻辑 → 数据库 → 响应
    
    详细步骤:
    1. 前端发送 HTTP 请求
    2. Django 根据 urls.py 找到对应视图
    3. 视图函数解析请求参数
    4. 调用业务逻辑 (SignalLibrary)
    5. 执行数据库操作 (如需要)
    6. 组装 JSON 响应
    7. 返回给前端
    """
    pass
```

---

## 🔨 开发规范

### 1. 代码风格

**Python 代码规范 (PEP 8)**

```python
# ✅ 好的命名
def calculate_moving_average(prices, window=20):
    """计算移动平均线"""
    return prices.rolling(window=window).mean()

class TechnicalIndicator:
    """技术指标基类"""
    
    def __init__(self, period=14):
        self.period = period
    
    def calculate(self, data):
        raise NotImplementedError

# ❌ 避免的命名
def calc_ma(p, w=20):  # 名称太短
    return p.rolling(window=w).mean()

def CalculateMovingAverage():  # 函数名不应该用 CamelCase
    pass
```

**注释规范**

```python
def generate_macd_signal(df, fast=12, slow=26, signal=9):
    """
    生成 MACD 交易信号
    
    Args:
        df (pd.DataFrame): 包含 CLOSE 列的价格数据
        fast (int): 快速 EMA 周期，默认 12
        slow (int): 慢速 EMA 周期，默认 26  
        signal (int): 信号线周期，默认 9
    
    Returns:
        pd.Series: 买入信号序列，买入时为 15，其他为 None
        
    Example:
        >>> df = pd.read_csv('000001_10years.csv')
        >>> signals = generate_macd_signal(df)
        >>> print(f"生成 {signals.notna().sum()} 个信号")
    """
    # 计算 MACD 指标
    macd_result = macd.calculate(df, fast, slow, signal)
    dif, dea = macd_result[0], macd_result[1]
    
    # 判断金叉信号: DIF 上穿 DEA
    golden_cross = ((dif.shift(1) <= dea.shift(1)) & (dif > dea))
    
    # 生成信号序列
    return golden_cross.apply(lambda x: 15 if x else None)
```

### 2. 错误处理

**统一的错误处理模式**

```python
def safe_execute_trade(self, action, stock_code, price, shares):
    """
    安全的交易执行，包含完整错误处理
    """
    try:
        # 参数验证
        if not stock_code or not isinstance(stock_code, str):
            raise ValueError("股票代码必须是非空字符串")
        
        if price <= 0:
            raise ValueError("股票价格必须大于 0")
            
        if shares <= 0:
            raise ValueError("股票数量必须大于 0")
        
        # 执行交易
        if action == 'buy':
            result = self.execute_buy_trade(stock_code, price, shares)
        elif action == 'sell':
            result = self.execute_sell_trade(stock_code, price, shares)
        else:
            raise ValueError(f"不支持的交易操作: {action}")
        
        return result
        
    except ValueError as e:
        logger.warning(f"参数错误: {e}")
        return {'success': False, 'reason': f'参数错误: {e}'}
        
    except Exception as e:
        logger.error(f"交易执行异常: {e}", exc_info=True)
        return {'success': False, 'reason': f'系统错误: {e}'}
```

**API 错误响应标准**

```python
def standardized_api_response(view_func):
    """
    标准化 API 响应装饰器
    """
    def wrapper(request, *args, **kwargs):
        try:
            result = view_func(request, *args, **kwargs)
            
            # 确保返回标准格式
            if isinstance(result, dict):
                return JsonResponse({
                    'status': 'success',
                    'data': result,
                    'timestamp': datetime.now().isoformat()
                })
            return result
            
        except ValidationError as e:
            return JsonResponse({
                'status': 'error',
                'error_code': 'VALIDATION_ERROR',
                'message': str(e),
                'timestamp': datetime.now().isoformat()
            }, status=400)
            
        except Exception as e:
            logger.error(f"API 异常: {e}", exc_info=True)
            return JsonResponse({
                'status': 'error',
                'error_code': 'INTERNAL_ERROR',
                'message': '服务器内部错误',
                'timestamp': datetime.now().isoformat()
            }, status=500)
    
    return wrapper
```

### 3. 测试规范

**单元测试示例**

```python
import unittest
from signal_library import SignalLibrary
import pandas as pd
import numpy as np

class TestSignalLibrary(unittest.TestCase):
    """信号库单元测试"""
    
    def setUp(self):
        """测试前准备"""
        self.signal_lib = SignalLibrary(initial_balance=100000)
        
        # 创建测试数据
        dates = pd.date_range('2023-01-01', periods=100, freq='D')
        prices = 20 + np.cumsum(np.random.randn(100) * 0.1)
        
        self.test_df = pd.DataFrame({
            'date': dates,
            'OPEN': prices * 0.99,
            'HIGH': prices * 1.02,
            'LOW': prices * 0.98,
            'CLOSE': prices,
            'VOLUME': np.random.randint(10000, 50000, 100)
        })
    
    def test_buy_signal_generation(self):
        """测试买入信号生成"""
        signals = self.signal_lib.generate_buy_signal(
            '000001', self.test_df, 'basic'
        )
        
        # 验证信号格式
        self.assertIsInstance(signals, pd.Series)
        self.assertEqual(len(signals), len(self.test_df))
        
        # 验证信号值
        signal_values = signals.dropna().unique()
        for value in signal_values:
            self.assertEqual(value, 15)  # 买入信号代码
    
    def test_buy_trade_execution(self):
        """测试买入交易执行"""
        result = self.signal_lib.execute_buy_trade('000001', 20.0, 100, '2023-01-01')
        
        # 验证交易成功
        self.assertTrue(result['success'])
        self.assertEqual(result['shares'], 100)
        self.assertEqual(result['price'], 20.0)
        
        # 验证账户状态
        self.assertLess(self.signal_lib.current_balance, 100000)
        self.assertIn('000001', self.signal_lib.positions)
    
    def test_insufficient_funds(self):
        """测试资金不足情况"""
        # 尝试买入超出资金的股票
        result = self.signal_lib.execute_buy_trade('000001', 1000.0, 1000, '2023-01-01')
        
        # 应该自动调整为最大可买数量，或返回失败
        if result['success']:
            # 自动调整数量
            self.assertLess(result['shares'], 1000)
        else:
            # 资金不足，拒绝交易
            self.assertIn('资金不足', result['reason'])

if __name__ == '__main__':
    unittest.main()
```

**集成测试示例**

```python
def test_complete_workflow():
    """完整工作流程集成测试"""
    
    # 1. 创建信号库
    signal_lib = SignalLibrary(100000)
    
    # 2. 加载测试数据
    df = pd.read_csv('000001_10years.csv')
    
    # 3. 生成信号
    buy_signals = signal_lib.generate_buy_signal('000001', df, 'smart')
    sell_signals = signal_lib.generate_sell_signal('000001', df, 'smart')
    
    # 4. 验证信号
    assert buy_signals.notna().sum() > 0, "应该生成买入信号"
    assert sell_signals.notna().sum() > 0, "应该生成卖出信号"
    
    # 5. 检查账户状态
    summary = signal_lib.get_account_summary()
    assert summary['total_trades'] > 0, "应该有交易记录"
    
    print("✅ 完整工作流程测试通过")
```

---

## 🔧 常见开发任务

### 1. 添加新的技术指标

**Step 1: 创建指标文件**

```python
# indicators/rsi.py
import pandas as pd

def calculate(df, period=14):
    """
    计算 RSI (相对强弱指标)
    
    Args:
        df: 包含 CLOSE 列的 DataFrame
        period: 计算周期，默认 14
        
    Returns:
        pd.Series: RSI 值序列 (0-100)
    """
    close = df['CLOSE']
    
    # 计算价格变化
    delta = close.diff()
    
    # 分离上涨和下跌
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    
    # 计算平均涨跌幅
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    
    # 计算 RSI
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    
    return rsi

# 使用示例
if __name__ == '__main__':
    import pandas as pd
    
    # 测试数据
    df = pd.DataFrame({
        'CLOSE': [20, 21, 19, 22, 23, 21, 24, 26, 25, 27]
    })
    
    rsi = calculate(df, period=5)
    print(f"RSI 值: {rsi.iloc[-1]:.2f}")
```

**Step 2: 在信号库中使用**

```python
# signal_library.py
def _rsi_buy_signal(self, stock_code, df, **kwargs):
    """基于 RSI 的买入信号"""
    oversold_threshold = kwargs.get('oversold_threshold', 30)
    period = kwargs.get('rsi_period', 14)
    
    try:
        # 导入 RSI 指标
        from indicators import rsi
        
        # 计算 RSI
        rsi_values = rsi.calculate(df, period=period)
        
        # RSI 从超卖区域向上突破
        buy_condition = ((rsi_values.shift(1) <= oversold_threshold) & 
                        (rsi_values > oversold_threshold))
        
        signals = buy_condition.apply(lambda x: SIGNAL_CODES['buy_signal'] if x else None)
        
        # 记录信号
        for idx, signal in signals.items():
            if signal == SIGNAL_CODES['buy_signal']:
                self._record_signal(stock_code, 'buy', 'rsi_oversold', df.loc[idx], idx)
        
        return signals
        
    except Exception as e:
        print(f"RSI 买入信号计算失败: {e}")
        return pd.Series([None] * len(df), index=df.index)

# 在 generate_buy_signal 中添加新策略
def generate_buy_signal(self, stock_code, df, signal_type='basic', **kwargs):
    if signal_type == 'rsi_oversold':
        return self._rsi_buy_signal(stock_code, df, **kwargs)
    # ... 其他策略
```

### 2. 添加新的 API 接口

**Step 1: 创建视图函数**

```python
# backtest_integration.py
@standardized_api_response
def get_technical_indicators_api(request):
    """
    获取技术指标数据 API
    
    GET /api/indicators/?stock_code=000001&indicators=ma,rsi,macd
    """
    try:
        stock_code = request.GET.get('stock_code')
        indicators_param = request.GET.get('indicators', 'ma,rsi,macd')
        
        if not stock_code:
            raise ValidationError("股票代码不能为空")
        
        # 解析指标列表
        indicator_list = indicators_param.split(',')
        
        # 加载股票数据
        df = load_stock_data(stock_code)
        
        # 计算指标
        result = {}
        for indicator in indicator_list:
            if indicator == 'ma':
                result['ma5'] = df['CLOSE'].rolling(5).mean().tolist()
                result['ma20'] = df['CLOSE'].rolling(20).mean().tolist()
            elif indicator == 'rsi':
                from indicators import rsi
                result['rsi'] = rsi.calculate(df).tolist()
            elif indicator == 'macd':
                from indicators import macd
                dif, dea, macd_hist = macd.calculate(df)
                result['macd'] = {
                    'dif': dif.tolist(),
                    'dea': dea.tolist(),
                    'histogram': macd_hist.tolist()
                }
        
        return {
            'stock_code': stock_code,
            'indicators': result,
            'dates': df['date'].dt.strftime('%Y-%m-%d').tolist()
        }
        
    except Exception as e:
        raise Exception(f"技术指标计算失败: {e}")
```

**Step 2: 添加 URL 路由**

```python
# myproject/urls.py
from django.urls import path
from backtest_integration import get_technical_indicators_api

urlpatterns = [
    path('api/backtest/config/', get_backtest_config_api, name='backtest_config'),
    path('api/backtest/run/', run_backtest_api, name='run_backtest'),
    path('api/indicators/', get_technical_indicators_api, name='technical_indicators'),  # 新增
]
```

**Step 3: 前端调用**

```javascript
// frontend/src/js/api.js
async function getTechnicalIndicators(stockCode, indicators = ['ma', 'rsi', 'macd']) {
    const params = new URLSearchParams({
        stock_code: stockCode,
        indicators: indicators.join(',')
    });
    
    const response = await fetch(`${API_BASE_URL}/api/indicators/?${params}`);
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.status === 'error') {
        throw new Error(data.message);
    }
    
    return data.data;
}

// 使用示例
async function displayIndicators() {
    try {
        const data = await getTechnicalIndicators('000001', ['ma', 'rsi']);
        console.log('技术指标数据:', data);
        
        // 更新图表或表格
        updateChart(data);
        
    } catch (error) {
        console.error('获取技术指标失败:', error);
        showErrorMessage('获取技术指标失败: ' + error.message);
    }
}
```

### 3. 数据源扩展

**添加新的数据源接口**

```python
# data_sources/yahoo_finance.py
import yfinance as yf
import pandas as pd

class YahooFinanceSource:
    """Yahoo Finance 数据源"""
    
    def __init__(self):
        self.name = "Yahoo Finance"
    
    def get_stock_data(self, symbol, start_date=None, end_date=None):
        """
        获取股票数据
        
        Args:
            symbol: 股票代码 (如 '000001.SZ')
            start_date: 开始日期
            end_date: 结束日期
            
        Returns:
            pd.DataFrame: 标准格式的股票数据
        """
        try:
            # 下载数据
            ticker = yf.Ticker(symbol)
            df = ticker.history(start=start_date, end=end_date)
            
            # 转换为标准格式
            df = df.reset_index()
            df = df.rename(columns={
                'Date': 'date',
                'Open': 'OPEN',
                'High': 'HIGH',
                'Low': 'LOW',
                'Close': 'CLOSE',
                'Volume': 'VOLUME'
            })
            
            return df
            
        except Exception as e:
            raise Exception(f"Yahoo Finance 数据获取失败: {e}")
    
    def validate_symbol(self, symbol):
        """验证股票代码"""
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            return info.get('symbol') is not None
        except:
            return False

# 数据源管理器
class DataSourceManager:
    """数据源管理器"""
    
    def __init__(self):
        self.sources = {
            'csv': CSVDataSource(),
            'tushare': TushareDataSource(),
            'yahoo': YahooFinanceSource(),
        }
        self.default_source = 'csv'
    
    def get_stock_data(self, symbol, source=None, **kwargs):
        """
        从指定数据源获取股票数据
        """
        if source is None:
            source = self.default_source
        
        if source not in self.sources:
            raise ValueError(f"不支持的数据源: {source}")
        
        return self.sources[source].get_stock_data(symbol, **kwargs)
    
    def add_source(self, name, source_instance):
        """添加新的数据源"""
        self.sources[name] = source_instance

# 使用示例
data_manager = DataSourceManager()

# 从不同数据源获取数据
csv_data = data_manager.get_stock_data('000001', source='csv')
yahoo_data = data_manager.get_stock_data('000001.SZ', source='yahoo', 
                                       start_date='2023-01-01')
```

---

## 🐛 调试技巧

### 1. 常用调试方法

**使用 Python 内置调试器**

```python
import pdb

def debug_signal_generation():
    """调试信号生成过程"""
    signal_lib = SignalLibrary()
    df = load_test_data()
    
    # 设置断点
    pdb.set_trace()
    
    # 单步执行信号生成
    signals = signal_lib.generate_buy_signal('000001', df, 'macd_golden')
    
    # 检查中间结果
    print(f"生成信号数: {signals.notna().sum()}")
    print(f"信号位置: {signals.dropna().index.tolist()}")
```

**使用日志调试**

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

def debug_with_logging():
    """使用日志调试"""
    logger.debug("开始信号生成")
    
    try:
        # 业务逻辑
        result = generate_signals()
        logger.info(f"信号生成成功: {len(result)}")
        
    except Exception as e:
        logger.error(f"信号生成失败: {e}", exc_info=True)
```

**性能分析**

```python
import time
import cProfile

def profile_signal_generation():
    """性能分析信号生成"""
    
    def run_test():
        signal_lib = SignalLibrary()
        df = load_large_dataset()  # 大数据集
        
        start_time = time.time()
        signals = signal_lib.generate_buy_signal('000001', df, 'smart')
        end_time = time.time()
        
        print(f"执行时间: {end_time - start_time:.2f} 秒")
        return signals
    
    # 详细性能分析
    cProfile.run('run_test()', 'profile_results.txt')

# 查看分析结果
# python -c "import pstats; p = pstats.Stats('profile_results.txt'); p.sort_stats('time').print_stats(20)"
```

### 2. 前端调试

**浏览器开发者工具**

```javascript
// 添加调试输出
function debugApiCall() {
    console.group('API 调用调试');
    
    fetch('/api/backtest/config/')
        .then(response => {
            console.log('响应状态:', response.status);
            console.log('响应头:', response.headers);
            return response.json();
        })
        .then(data => {
            console.log('响应数据:', data);
            console.table(data.available_stocks);  // 表格形式显示
        })
        .catch(error => {
            console.error('请求失败:', error);
        })
        .finally(() => {
            console.groupEnd();
        });
}

// 网络请求监控
function monitorNetworkRequests() {
    const originalFetch = window.fetch;
    
    window.fetch = function(...args) {
        console.log('发起请求:', args[0]);
        
        return originalFetch.apply(this, args)
            .then(response => {
                console.log(`请求完成: ${args[0]} - ${response.status}`);
                return response;
            });
    };
}
```

### 3. API 调试

**使用 Django Debug Toolbar**

```python
# settings.py
if DEBUG:
    INSTALLED_APPS += ['debug_toolbar']
    MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
    
    INTERNAL_IPS = ['127.0.0.1']
    
    DEBUG_TOOLBAR_CONFIG = {
        'SHOW_TOOLBAR_CALLBACK': lambda request: True,
    }

# urls.py  
if settings.DEBUG:
    import debug_toolbar
    urlpatterns += [path('__debug__/', include(debug_toolbar.urls))]
```

**API 响应时间监控**

```python
import time
from functools import wraps

def monitor_api_performance(func):
    """监控 API 性能装饰器"""
    @wraps(func)
    def wrapper(request, *args, **kwargs):
        start_time = time.time()
        
        try:
            response = func(request, *args, **kwargs)
            
            end_time = time.time()
            duration = end_time - start_time
            
            # 记录性能数据
            logger.info(f"API 性能: {request.path} - {duration:.3f}s")
            
            # 慢查询警告
            if duration > 2.0:
                logger.warning(f"慢查询警告: {request.path} 耗时 {duration:.3f}s")
            
            return response
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            logger.error(f"API 异常: {request.path} - {duration:.3f}s - {e}")
            raise
    
    return wrapper

# 使用装饰器
@monitor_api_performance
def run_backtest_api(request):
    # API 逻辑
    pass
```

---

## 📚 学习资源

### 1. 技术文档

**Django 相关**
- [Django 官方文档](https://docs.djangoproject.com/)
- [Django REST Framework](https://www.django-rest-framework.org/)
- [Django CORS Headers](https://github.com/adamchainz/django-cors-headers)

**数据分析相关**
- [Pandas 官方文档](https://pandas.pydata.org/docs/)
- [NumPy 用户指南](https://numpy.org/doc/stable/user/)
- [技术指标计算方法](https://technical-analysis-library-in-python.readthedocs.io/)

**量化交易相关**
- [Quantlib Python](https://quantlib-python-docs.readthedocs.io/)
- [Backtrader 文档](https://www.backtrader.com/docu/)
- [TuShare 文档](https://tushare.pro/document/2)

### 2. 代码示例

**完整的开发示例**

```python
"""
示例: 开发一个新的技术指标和对应的交易策略

任务: 实现 Bollinger Bands (布林带) 指标和基于布林带的交易策略
"""

# Step 1: 实现技术指标
# indicators/bollinger_bands.py
import pandas as pd
import numpy as np

def calculate(df, period=20, std_dev=2):
    """
    计算布林带指标
    
    Args:
        df: 包含 CLOSE 列的 DataFrame
        period: 移动平均周期
        std_dev: 标准差倍数
        
    Returns:
        tuple: (upper_band, middle_band, lower_band)
    """
    close = df['CLOSE']
    
    # 中轨: 简单移动平均
    middle_band = close.rolling(window=period).mean()
    
    # 标准差
    rolling_std = close.rolling(window=period).std()
    
    # 上轨和下轨
    upper_band = middle_band + (rolling_std * std_dev)
    lower_band = middle_band - (rolling_std * std_dev)
    
    return upper_band, middle_band, lower_band

# Step 2: 在信号库中实现策略
# signal_library.py (添加方法)
def _bollinger_buy_signal(self, stock_code, df, **kwargs):
    """布林带买入信号: 价格从下轨反弹"""
    period = kwargs.get('bb_period', 20)
    std_dev = kwargs.get('bb_std_dev', 2)
    
    from indicators import bollinger_bands
    
    upper_band, middle_band, lower_band = bollinger_bands.calculate(
        df, period=period, std_dev=std_dev
    )
    
    close = df['CLOSE']
    
    # 买入条件: 价格触及下轨后反弹
    touch_lower = close <= lower_band
    bounce_up = (close.shift(1) <= lower_band.shift(1)) & (close > lower_band)
    
    buy_condition = touch_lower.shift(1) & bounce_up
    
    signals = buy_condition.apply(lambda x: SIGNAL_CODES['buy_signal'] if x else None)
    
    # 记录信号
    for idx, signal in signals.items():
        if signal == SIGNAL_CODES['buy_signal']:
            self._record_signal(stock_code, 'buy', 'bollinger_bounce', df.loc[idx], idx)
    
    return signals

def _bollinger_sell_signal(self, stock_code, df, **kwargs):
    """布林带卖出信号: 价格触及上轨"""
    period = kwargs.get('bb_period', 20)
    std_dev = kwargs.get('bb_std_dev', 2)
    
    from indicators import bollinger_bands
    
    upper_band, middle_band, lower_band = bollinger_bands.calculate(
        df, period=period, std_dev=std_dev
    )
    
    close = df['CLOSE']
    
    # 卖出条件: 价格触及或突破上轨
    sell_condition = close >= upper_band
    
    signals = sell_condition.apply(lambda x: SIGNAL_CODES['sell_signal'] if x else None)
    
    # 记录信号
    for idx, signal in signals.items():
        if signal == SIGNAL_CODES['sell_signal']:
            self._record_signal(stock_code, 'sell', 'bollinger_upper', df.loc[idx], idx)
    
    return signals

# Step 3: 在主要方法中添加新策略
def generate_buy_signal(self, stock_code, df, signal_type='basic', **kwargs):
    if signal_type == 'bollinger_bounce':
        return self._bollinger_buy_signal(stock_code, df, **kwargs)
    # ... 其他策略

def generate_sell_signal(self, stock_code, df, signal_type='basic', **kwargs):
    if signal_type == 'bollinger_upper':
        return self._bollinger_sell_signal(stock_code, df, **kwargs)
    # ... 其他策略

# Step 4: 测试新策略
def test_bollinger_strategy():
    """测试布林带策略"""
    signal_lib = SignalLibrary(100000)
    df = pd.read_csv('000001_10years.csv')
    
    # 生成买入信号
    buy_signals = signal_lib.generate_buy_signal(
        '000001', df, 'bollinger_bounce',
        bb_period=20, bb_std_dev=2
    )
    
    # 生成卖出信号
    sell_signals = signal_lib.generate_sell_signal(
        '000001', df, 'bollinger_upper',
        bb_period=20, bb_std_dev=2
    )
    
    print(f"布林带买入信号: {buy_signals.notna().sum()}")
    print(f"布林带卖出信号: {sell_signals.notna().sum()}")
    
    # 查看交易结果
    summary = signal_lib.get_trading_summary('000001')
    print(f"策略收益率: {summary['profit_rate']:.2f}%")

if __name__ == '__main__':
    test_bollinger_strategy()
```

### 3. 最佳实践总结

**开发流程最佳实践**

1. **需求分析** → 明确功能需求和技术要求
2. **技术设计** → 设计 API 接口和数据结构  
3. **单元测试** → 编写测试用例
4. **功能实现** → 实现核心逻辑
5. **集成测试** → 测试完整流程
6. **性能优化** → 分析和优化性能瓶颈
7. **文档更新** → 更新相关文档

**代码质量检查清单**

- [ ] 代码符合 PEP 8 规范
- [ ] 函数和类有完整的文档字符串
- [ ] 关键逻辑有适当的注释
- [ ] 异常处理覆盖主要错误场景
- [ ] 有对应的单元测试
- [ ] 性能测试通过
- [ ] API 接口文档已更新

---

## 🚀 部署与发布

### 生产环境部署检查清单

**安全配置**
- [ ] DEBUG = False
- [ ] SECRET_KEY 使用环境变量
- [ ] 数据库密码使用环境变量
- [ ] HTTPS 配置
- [ ] CORS 策略限制
- [ ] API 访问频率限制

**性能配置**
- [ ] 数据库连接池配置
- [ ] 静态文件 CDN 配置
- [ ] Redis 缓存配置
- [ ] 日志文件轮转配置
- [ ] 监控告警配置

**备份策略**
- [ ] 数据库自动备份
- [ ] 代码版本管理
- [ ] 配置文件备份
- [ ] 日志文件归档

---

**文档版本**: v1.0.0  
**最后更新**: 2025-08-04  
**维护者**: 系统集成团队

📧 **技术支持**: 通过 GitHub Issues 提交问题  
🔄 **持续更新**: 本文档将随项目发展持续更新
